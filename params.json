{
  "name": "Config",
  "tagline": "A type safe, purely functional configuration library for Scala",
  "body": "# config: a type safe, purely functional configuration library for Scala\r\n\r\n## Not only another Typesafe's config wrapper\r\nRight from the start I didn't want to depend on other config libraries when I started implementing this one so I wrote\r\nmy own parser for a simple JSON-like syntax.\r\nHence, this is not just another [Typesafe's config](https://github.com/typesafehub/config) wrapper. Of course,\r\nif you are already using Typesafe's config library and/or just\r\nprefer [HOCON](https://github.com/typesafehub/config/blob/master/HOCON.md) syntax for your configuration,\r\nthere's an adapter that will convert a Typesafe `Config` object into this config's AST.\r\nSee [this example](#typesafeConfig).\r\n\r\n## Configuration Syntax\r\nThe syntax expected by this library is a JSON-superset. This means that any JSON file\r\nshould be a valid configuration. However, the `null` JSON values can only be converted to `Option[A]`, where `A` \r\nis the type you expect, because, of course, we don't fancy `null` in Scala code. The *superset* part means that:\r\n  \r\n* You can optionally use `=` instead of `:`\r\n* You can avoid putting the keys between quotes, unless your key contains white spaces\r\n* You can use a Scala [Duration](http://www.scala-lang.org/api/current/index.html#scala.concurrent.duration.Duration)\r\n* You can use a Scala [Range](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Range)\r\n\r\n## Using config\r\nAs a first step you need to add the dependency to your build file:\r\n\r\n```scala\r\nlibraryDependencies += \"com.lambdista\" %% \"config\" % configVersion\r\n```\r\n\r\nNote that `configVersion` is the version you want to use. \r\nYou can find all the released versions [here](https://github.com/lambdista/config/releases).\r\n\r\nAt the moment only Scala 2.11.x is supported. Support for Scala 2.10.x might be added in future releases.\r\n\r\n## Usage\r\nOk, let's see the typical usage scenarios. As a use case consider the following configuration, unless otherwise specified:\r\n\r\n```\r\n{\r\n  bar = \"hello\",\r\n  baz = 42,\r\n  list = [1, 2, 3],\r\n  mapList = [\r\n    {\r\n      alpha = \"hello\",\r\n      beta = 42\r\n    },\r\n    {\r\n      alpha = \"world\",\r\n      beta = 24\r\n    }\r\n  ],\r\n  range = 2 to 10 by 2,\r\n  duration = 5 seconds\r\n}\r\n```\r\n\r\nSuppose the previous configuration is at the relative path will be: `core/src/test/resources/foo.conf`.\r\n\r\nYou can move around a config choosing one of two approaches: *functional* and *imperative*.\r\nIn the following examples you'll see both.\r\n\r\n### Functional Approach\r\nIt consists in moving aroung the config through `map` and `flatMap` of the `Try` type, or, analogously, through\r\nthe `for expression`. Here are some examples.\r\n\r\nFirst thing first, load and parse your config:\r\n\r\n```scala\r\nimport scala.util.Try\r\n\r\nimport java.nio.file.Paths\r\n\r\nval confPath = \"core/src/test/resources/foo.conf\"\r\n\r\nval config: Try[Config] = Config.from(Paths.get(confPath))\r\n```\r\n\r\nApart from `java.nio.file.Path` you can load your config from other resources using [Config Loaders](#configLoaders).\r\n \r\nAs you can see the result is a `Try[Config]`. Indeed you can get two types of error here:\r\n\r\n* The resource cannot be found.\r\n* The resource can be found but its parsing failed.\r\n\r\nIn both cases you would get a `Failure` wrapping the appropriate exception.\r\n\r\nOnce you have a `Config` object you can do two main things with it:\r\n\r\n* Convert it entirely into a case class representing the whole configuration.\r\n* Retrieve a single value and convert it to whatever it's convertible to.\r\n\r\n#### Conversion to a case class\r\nHere's how you would map the `foo.conf` file to a case class:\r\n\r\n```scala\r\ncase class Greek(alpha: String, beta: Int)\r\n\r\ncase class FooConfig(bar: String, baz: Option[Int], list: List[Int], mapList: List[Greek], range: Range, duration: Duration)\r\n\r\nval fooConfig: Try[FooConfig] = for {\r\n  conf <- config\r\n  result <- conf.tryAs[FooConfig]\r\n} yield result\r\n```\r\n\r\nThe value of `fooConfig` will be:\r\n\r\n```scala\r\nSuccess(FooConfig(hello,Some(42),List(1, 2, 3),List(Greek(hello,42), Greek(world,24)),Range(2, 4, 6, 8, 10),5 seconds))\r\n```\r\n\r\nHere you can already notice some interesting features of this library:\r\n\r\n* The conversion to a case class happens automatically, no boilerplate on the client side is required.\r\n* Since `baz` is declared as `Option[Int]` the library automatically wraps the `Int` value into a `Some`.\r\n* The automatic conversion works also for nested structures, see `mapList` for example.\r\n* `Range` and `Duration` work like a charm. Note that for both `Range` and `Duration` you can use the syntax you\r\nwould use in regular Scala code. For example, you could have used `5 secs` instead of `5 seconds` in `foo.conf` and\r\nit would have worked smoothly.\r\n\r\n#### Retrieve and convert a single value\r\nInstead of using a case class you may want to retrieve the single values and convert them as you go:\r\n\r\n```scala\r\nval bar: Try[String] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[String](\"bar\")\r\n} yield result\r\n```\r\n\r\nThe value of `bar` will be:\r\n\r\n```scala\r\nSuccess(\"hello\")\r\n```\r\n\r\nYou can also use the *dot* syntax to retrieve a value. For example suppose you have the following configuration:\r\n\r\n```\r\n{\r\n  foo = {\r\n    bar = 42\r\n  }\r\n}\r\n```\r\n\r\nOnce loaded you could retrieve the `bar` value as follows:\r\n\r\n```scala\r\n// val config: Try[Config] = ...\r\n\r\nval bar: Try[Int] = for {\r\n  c <- config\r\n  bar <- c.tryGet[Int](\"foo.bar\")\r\n} yield bar\r\n```\r\n\r\nApart from converting the whole config into a case class, you can also convert a given value provided it's an object in\r\nthe JSON-superset syntax:\r\n\r\n```scala\r\nval greekList: Try[List[Greek]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[List[Greek]](\"mapList\")\r\n} yield result\r\n```\r\n\r\nThe value of `greekList` will be:\r\n\r\n```scala\r\nSuccess(List(Greek(hello,42), Greek(world,24)))\r\n```\r\n\r\nSorry? You said you would have preferred a `Vector[Greek]` in place of `List[Greek]`? No problem:\r\n\r\n```scala\r\nval greekVector: Try[Vector[Greek]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[Vector[Greek]](\"mapList\")\r\n} yield result\r\n```\r\n\r\nHere's the value of `greekVector`:\r\n\r\n```scala\r\nSuccess(Vector(Greek(hello,42), Greek(world,24)))\r\n```\r\n\r\nOh, yes, `Set[Greek]` would have worked too:\r\n\r\n```scala\r\nval greekSet: Try[Set[Greek]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[Set[Greek]](\"mapList\")\r\n} yield result\r\n```\r\n\r\nHere's the value of `greekSet`:\r\n\r\n```scala\r\nSuccess(Set(Greek(hello,42), Greek(world,24)))\r\n```\r\n\r\nAnalogously you can automatically convert a `Range` into a `List`, `Vector` or `Set`:\r\n\r\n```scala\r\nval rangeAsList: Try[List[Int]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[List[Int]](\"range\")\r\n} yield result\r\n\r\nval rangeAsVector: Try[Vector[Int]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[Vector[Int]](\"range\")\r\n} yield result\r\n\r\nval rangeAsSet: Try[Set[Int]] = for {\r\n  conf <- config\r\n  result <- conf.tryGet[Set[Int]](\"range\")\r\n} yield result\r\n```\r\n\r\nHere are the results:\r\n\r\n```scala\r\nSuccess(List(2, 4, 6, 8, 10)) // rangeAsList\r\n\r\nSuccess(Vector(2, 4, 6, 8, 10)) // rangeAsVector\r\n\r\nSuccess(Set(4, 2, 8, 6, 10)) // rangeAsSet\r\n```\r\n\r\nNotice, however, that in case of `Set` the order is not guaranteed because of the very nature of sets.\r\n\r\n### Imperative Approach\r\nIf you feel *confident* and prefer not to move within a `Try` you can opt for the *imperative* fashion. In this case, \r\nif the config element is not found or cannot be converted into the desired type an exception is thrown.\r\nHere's an example:\r\n\r\n```scala\r\nval config: Config = Config.from(Paths.get(confPath)).get // calling .get you \"get out\" of the Try type\r\n\r\nval fooConfig: FooConfig = config.as[FooConfig] // conversion to a case class...\r\n\r\n// ...or just retrieve the config elements one by one as in the following cases\r\nval bar: String = config.get[String](\"bar\")\r\nval range: Range = config.get[Range](\"range\")\r\n```\r\n\r\nOf course you could also retrieve optional values from config and fall back on defaults in case they're missing:\r\n\r\n```scala\r\nval age: Int = config.tryGet[Int](\"age\").getOrElse(42) // result -> 42\r\n```\r\n\r\n<a name=\"configLoaders\"></a>\r\n### Config Loaders\r\nApart from loading your config through a `java.nio.file.Path` you can also use the following resources:\r\n\r\n* String\r\n* java.io.File\r\n* scala.io.Source\r\n* java.net.URI\r\n* java.net.URL\r\n* com.typesafe.config.Config\r\n\r\nIf that's not enough it's not so difficult provide your implementation of the `ConfigLoader` type class and make it\r\navailable in scope. Here's how the `ConfigLoader` looks like:\r\n\r\n```scala\r\ntrait ConfigLoader[R] {\r\n  def load(resource: R): Try[Config]\r\n}\r\n```\r\n\r\nActually all you need to do is find a way to *read* your resource into a `String` and your done. Have a look at the\r\n`ConfigLoader` companion object for some examples.\r\n\r\n#### Loading config from a simple String\r\nWhat follows is an example of loading the config from a simple `String`. In this example you can also appreciate\r\ntwo other features of the library: how it deals with `null` values and its ability to convert char ranges too.\r\n\r\n```scala\r\nval confStr: String = \"{age = null, charRange = 'a' to 'z'}\"\r\n    \r\nval config: Config = Config.from(confStr).get\r\n\r\nval age: Option[Int] = config.get[Option[Int]](\"age\")\r\n\r\nval charRange: List[Char] = config.get[List[Char]](\"charRange\")\r\n```\r\n\r\nAs you may expect the values of `age` and `charRange` will be:\r\n\r\n```scala\r\nNone // age\r\n\r\nList(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z) // charRange\r\n```\r\n\r\n<a name=\"typesafeConfig\"></a>\r\n#### Loading a config from Typesafe Config\r\nHere's how simple is loading a configuration passing through Typesafe config library. First thing first, you need to add\r\nthe dependency for the Typesafe config adapter:\r\n\r\n```scala\r\nlibraryDependencies += \"com.lambdista\" %% \"config-typesafe\" % configVersion\r\n```\r\n\r\n`configVersion` is the same you used for the core library.\r\n\r\nThe example configuration is the following:\r\n```\r\nstring = \"hello\"\r\nint = 42\r\ndouble = 1.414\r\nboolean = true\r\nlist = [1, 2, 3]\r\nmapList = [\r\n  {\r\n    firstName = \"John\"\r\n    lastName = \"Doe\"\r\n  }\r\n  {\r\n    firstName = \"Jane\"\r\n    lastName = \"Doe\"\r\n  }\r\n]\r\n```\r\n\r\nSuppose it's in a file at the relative path `typesafe/src/test/resources/typesafe.conf`:\r\n\r\n```scala\r\nimport scala.util.Try\r\n\r\nimport java.io.File\r\nimport com.typesafe.config.{Config => TSConfig, ConfigFactory}\r\nimport com.lambdista.config.typesafe._ // important to bring into scope the ConfigLoader for Typesafe's Config\r\n\r\ncase class Person(firstName: String, lastName: String)\r\n\r\ncase class TypesafeConfig(string: String, int: Int, double: Double, boolean: Boolean, list: List[Int], mapList: List[Person])\r\n\r\nval confPath = \"typesafe/src/test/resources/typesafe.conf\"\r\n\r\nval tsConfig: TSConfig = ConfigFactory.parseFile(new File(confPath))\r\n\r\nval configTry: Try[Config] = Config.from(tsConfig)\r\n\r\nval typesafeConfigTry: Try[TypesafeConfig] = config.flatMap(_.tryAs[TypesafeConfig])\r\n\r\n// or, using the \"imperative\" way, outside the Try\r\nval config: Config = Config.from(tsConfig).get\r\n\r\nval typesafeConfig: TypesafeConfig = config.as[TypesafeConfig]\r\n```\r\n\r\nThe value of `typesafeConfig` and `typesafeConfigTry` will be:\r\n\r\n```scala\r\nTypesafeConfig(hello,42,1.414,true,List(1, 2, 3),List(Person(John,Doe), Person(Jane,Doe))) // typesafeConfig\r\n\r\nSuccess(TypesafeConfig(hello,42,1.414,true,List(1, 2, 3),List(Person(John,Doe), Person(Jane,Doe)))) // typesafeConfigTry\r\n```\r\n\r\n### Merging two configurations\r\nYou can also merge two configurations using the `softMerge` or `hardMerge` methods of `Config`, \r\nas in `config.softMerge(thatConfig)` or `config.hardMerge(thatConfig)`. The behaviour of the\r\nformer is that, given a key, if the correspondent value is a map then `thatConfig`'s value is\r\n*softly* merged to this config's value otherwise `thatConfig`'s value replaces this config's value. An example should\r\nclarify it:\r\n\r\n```scala\r\nval confStr1 = \"\"\"\r\n{\r\n  foo = {\r\n    alpha = 1,\r\n    bar = \"hello\"\r\n  },\r\n  baz = 42\r\n}\r\n\"\"\"\r\n\r\nval confStr2 = \"\"\"\r\n{\r\n  foo = {\r\n    baz = 15,\r\n    bar = \"goodbye\"\r\n  },\r\n  baz = 1,\r\n  zoo = \"hi\"\r\n}\r\n\"\"\"\r\n\r\nval config1: Config = Config.from(confStr1).get\r\n\r\nval config2: Config = Config.from(confStr2).get\r\n\r\nval mergedConfig: Config = config1.softMerge(config2)\r\n```\r\n\r\n`mergedConfig` will represent a config such as the following:\r\n```\r\n{\r\n  foo = {\r\n    alpha = 1,\r\n    baz = 15,\r\n    bar = \"goodbye\"\r\n  },\r\n  baz = 1,\r\n  zoo = \"hi\"\r\n}\r\n```\r\n\r\nAs you can see the value of `config2`'s `foo` did not replace entirely the value of `config1`'s `foo`, but they\r\nwere *softly* merged.\r\n\r\nOn the other hand `hardMerge`'s behaviour is more like Scala's default behaviour when using `++` between two `Map`s and\r\n`config2`'s values replace entirely `config1`'s values with the same key. E.g.:\r\n```scala\r\nval confStr1 = \"\"\"\r\n{\r\n  foo = {\r\n    alpha = 1,\r\n    bar = \"hello\"\r\n  },\r\n  zoo = \"hi\",\r\n  baz = 42\r\n}\r\n\"\"\"\r\n\r\nval confStr2 = \"\"\"\r\n{\r\n  foo = {\r\n    baz = 15,\r\n    bar = \"goodbye\"\r\n  },\r\n  baz = 1\r\n}\r\n\"\"\"\r\n\r\nval config1: Config = Config.from(confStr1).get\r\n\r\nval config2: Config = Config.from(confStr2).get\r\n\r\nval mergedConfig: Config = config1.softMerge(config2)\r\n``` \r\n\r\n`mergedConfig` will represent a config such as the following:\r\n```\r\n{\r\n  foo = {\r\n    baz = 15,\r\n    bar = \"goodbye\"\r\n  },\r\n  baz = 1,\r\n  zoo = \"hi\"\r\n}\r\n```\r\n\r\nLook at the tests for this library to see the examples in practise.\r\n\r\n## Bugs and Feedback\r\nFor bugs, questions and discussions please use [Github Issues](https://github.com/lambdista/config/issues).\r\n\r\n## License\r\nCopyright 2016 Alessandro Lacava.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance\r\nwith the License. You may obtain a copy of the License at\r\n\r\n[http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an\r\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and limitations under the License.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}